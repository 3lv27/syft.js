import { DimArray, IntDimArray, FloatDimArray } from './DimArray';
import { AsyncInit, IAsyncInit } from './AsyncInit';
export declare class Tensor extends AsyncInit implements IAsyncInit {
    static __tensor__: {
        [id: string]: Tensor;
    };
    id: string;
    data: DimArray;
    data_is_pointer: boolean;
    type: string;
    constructor($?: any);
    static deserialize(str: string): FloatTensor | IntTensor;
    serialize(optimizeStorage?: boolean): {
        data: ArrayBuffer;
        view: DataView;
        toString: any;
    };
    finish(id: string): void;
    delete(): Promise<void>;
    autograd(state: boolean): Promise<void>;
    params_func(name: string, params: any[], return_response?: boolean, return_type?: string, data_is_pointer?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    no_params_func(name: string, return_response?: boolean, return_type?: string): Promise<string | this | FloatTensor | IntTensor | null>;
    get(param_name?: string, response_as_tensor?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    protected cmd(functionCall: string, tensorIndexParams?: any[]): {
        'functionCall': string;
        'objectType': string;
        'objectIndex': string;
        'tensorIndexParams': any[];
    };
    is_contiguous(): Promise<boolean>;
    to_numpy(): Promise<string>;
    __repr__(verbose?: boolean): Promise<string>;
    abs(): Promise<string | this | FloatTensor | IntTensor | null>;
    abs_(): Promise<string | this | FloatTensor | IntTensor | null>;
    acos(): Promise<string | this | FloatTensor | IntTensor | null>;
    acos_(): Promise<string | this | FloatTensor | IntTensor | null>;
    addmm_(x: Tensor, y: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    addmm(x: Tensor, y: Tensor): Promise<Tensor>;
    addmv_(x: Tensor, y: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    addmv(x: Tensor, y: Tensor): Promise<Tensor>;
    asin(): Promise<string | this | FloatTensor | IntTensor | null>;
    asin_(): Promise<string | this | FloatTensor | IntTensor | null>;
    atan(): Promise<string | this | FloatTensor | IntTensor | null>;
    atan_(): Promise<string | this | FloatTensor | IntTensor | null>;
    __add__(x: Tensor): Promise<FloatTensor>;
    __iadd__(x: Tensor): Promise<FloatTensor>;
    backward(grad?: any): Promise<void>;
    ceil(): Promise<string | this | FloatTensor | IntTensor | null>;
    ceil_(): Promise<string | this | FloatTensor | IntTensor | null>;
    contiguous(): Promise<string | this | FloatTensor | IntTensor | null>;
    copy(): Promise<Tensor>;
    cos(): Promise<string | this | FloatTensor | IntTensor | null>;
    cos_(): Promise<string | this | FloatTensor | IntTensor | null>;
    cosh(): Promise<string | this | FloatTensor | IntTensor | null>;
    cosh_(): Promise<string | this | FloatTensor | IntTensor | null>;
    children(): Promise<never[]>;
    creation_op(): Promise<string | this | FloatTensor | IntTensor | null>;
    creators(): Promise<number[]>;
    cumsum(dim?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    dataOnGpu(): Promise<boolean>;
    exp(): Promise<string | this | FloatTensor | IntTensor | null>;
    exp_(): Promise<string | this | FloatTensor | IntTensor | null>;
    expand(...args: number[]): Promise<string | this | FloatTensor | IntTensor | null>;
    index_add(indices: any, dim: number, x: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    index_add_(indices: any, dim: number, x: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    index_select(dim: number, indices: any): Promise<string | this | FloatTensor | IntTensor | null>;
    __truediv__(x: Tensor): Promise<FloatTensor>;
    __itruediv__(x: Tensor): Promise<FloatTensor>;
    keepgrad(): Promise<boolean>;
    __pow__(x: Tensor): Promise<FloatTensor>;
    __ipow__(x: Tensor): Promise<FloatTensor>;
    pow(x: Tensor): Promise<FloatTensor>;
    pow_(x: Tensor): Promise<FloatTensor>;
    floor(): Promise<string | this | FloatTensor | IntTensor | null>;
    floor_(): Promise<string | this | FloatTensor | IntTensor | null>;
    round(): Promise<string | this | FloatTensor | IntTensor | null>;
    round_(): Promise<string | this | FloatTensor | IntTensor | null>;
    mm(x: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    grad(): Promise<string | this | FloatTensor | IntTensor | null>;
    __mod__(x: Tensor): Promise<FloatTensor>;
    __imod__(x: Tensor): Promise<FloatTensor>;
    __mul__(x: Tensor): Promise<FloatTensor>;
    __imul__(x: Tensor): Promise<FloatTensor>;
    __neg__(): Promise<string | this | FloatTensor | IntTensor | null>;
    neg(): Promise<string | this | FloatTensor | IntTensor | null>;
    neg_(): Promise<string | this | FloatTensor | IntTensor | null>;
    relu(): Promise<string | this | FloatTensor | IntTensor | null>;
    save(filename: string): Promise<string | this | FloatTensor | IntTensor | null>;
    set(param_name?: string, params?: any[]): Promise<string | this | FloatTensor | IntTensor | null>;
    sigmoid_(): Promise<string | this | FloatTensor | IntTensor | null>;
    sigmoid(): Promise<string | this | FloatTensor | IntTensor | null>;
    sign(): Promise<string | this | FloatTensor | IntTensor | null>;
    sign_(): Promise<string | this | FloatTensor | IntTensor | null>;
    sin(): Promise<string | this | FloatTensor | IntTensor | null>;
    sin_(): Promise<string | this | FloatTensor | IntTensor | null>;
    size(): Promise<string | this | FloatTensor | IntTensor | null>;
    shape(as_list?: boolean): Promise<string | number[] | this | FloatTensor | IntTensor | null>;
    softmax(dim?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    std(dim?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    stride(dim?: number): Promise<string | string[] | this | FloatTensor | IntTensor | null>;
    sqrt(): Promise<string | this | FloatTensor | IntTensor | null>;
    sqrt_(): Promise<string | this | FloatTensor | IntTensor | null>;
    trace(): Promise<string | this | FloatTensor | IntTensor | null>;
    trunc(): Promise<string | this | FloatTensor | IntTensor | null>;
    __sub__(x: Tensor): Promise<FloatTensor>;
    __isub__(x: Tensor): Promise<FloatTensor>;
    view(...args: any[]): Promise<string | this | FloatTensor | IntTensor | null>;
    view_(...args: any[]): Promise<this>;
    view_as(x: Tensor): Promise<string | this | FloatTensor | IntTensor | null>;
    view_as_(x: Tensor): Promise<this>;
    T(): Promise<string | this | FloatTensor | IntTensor | null>;
    triu(k?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    triu_(k?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    unsqueeze(dim: number): Promise<string | this | FloatTensor | IntTensor | null>;
    unsqueeze_(dim: number): Promise<string | this | FloatTensor | IntTensor | null>;
    zero_(): Promise<string | this | FloatTensor | IntTensor | null>;
    __str__(): Promise<string>;
    cpu(): Promise<string | this | FloatTensor | IntTensor | null>;
    gpu(): Promise<string | this | FloatTensor | IntTensor | null>;
    arithmetic_operation(x: number | Tensor, name: string, inline?: boolean): Promise<FloatTensor>;
    sinh(): Promise<string | this | FloatTensor | IntTensor | null>;
    sinh_(): Promise<string | this | FloatTensor | IntTensor | null>;
    log(): Promise<string | this | FloatTensor | IntTensor | null>;
    log_(): Promise<string | this | FloatTensor | IntTensor | null>;
    log1p_(): Promise<string | this | FloatTensor | IntTensor | null>;
    log1p(): Promise<string | this | FloatTensor | IntTensor | null>;
    frac(): Promise<string | this | FloatTensor | IntTensor | null>;
    frac_(): Promise<string | this | FloatTensor | IntTensor | null>;
    reciprocal(): Promise<string | this | FloatTensor | IntTensor | null>;
    reciprocal_(): Promise<string | this | FloatTensor | IntTensor | null>;
    rsqrt(): Promise<string | this | FloatTensor | IntTensor | null>;
    rsqrt_(): Promise<string | this | FloatTensor | IntTensor | null>;
    remainder(divisor: number): Promise<FloatTensor>;
    remainder_(divisor: number): Promise<any>;
    sample(dim: number): Promise<string | this | FloatTensor | IntTensor | null>;
    tan(): Promise<string | this | FloatTensor | IntTensor | null>;
    tan_(): Promise<string | this | FloatTensor | IntTensor | null>;
    tanh(): Promise<string | this | FloatTensor | IntTensor | null>;
    squeeze(dim?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    squeeze_(dim?: number): Promise<string | this | FloatTensor | IntTensor | null>;
    min(dim?: number, keepdim?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    max(dim?: number, keepdim?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    sum(dim?: number, keepdim?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    prod(dim?: number, keepdim?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
    mean(dim?: number, keepdim?: boolean): Promise<string | this | FloatTensor | IntTensor | null>;
}
export declare class IntTensor extends Tensor {
    data: IntDimArray;
    type: string;
    constructor(data: string | any[] | IntDimArray, data_is_pointer?: boolean);
}
export declare class FloatTensor extends Tensor {
    data: FloatDimArray;
    type: string;
    constructor(data: string | any[] | FloatDimArray, autograd?: boolean, data_is_pointer?: boolean);
}
